<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><!--
* PyWebCopy Engine [version 7.0.1]
* Copyright 2020; Raja Tomar
* File mirrored from [https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html]
* At UTC datetime: [2022-04-07 08:45:02.180557]
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-04-06T17:37:57.851267"><meta name="build-number" content="345">   <link rel="canonical" href="./coroutine-context-and-dispatchers.html" data-react-helmet="true">   <meta name="keywords" content="">   <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5P98');</script><script src="static/v3/analytics.js"></script>  <title>Coroutine context and dispatchers | Kotlin</title>   <link href="static/v3/app.css" rel="stylesheet">   
        
<link rel="icon" href="../assets/images/favicon_v2.svg" type="image/svg+xml">
<link rel="alternate icon" href="../assets/images/favicon_v2.ico" type="image/x-icon">
<link rel="apple-touch-icon" sizes="57x57" href="../assets/images/apple-touch-icon_v2.png">
<link rel="apple-touch-icon" sizes="72x72" href="../assets/images/apple-touch-icon-72x72_v2.png">
<link rel="apple-touch-icon" sizes="114x114" href="../assets/images/apple-touch-icon-114x114_v2.png">
<link rel="apple-touch-icon" sizes="144x144" href="../assets/images/apple-touch-icon-144x144_v2.png">
        
          <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Coroutine context and dispatchers | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Coroutine context and dispatchers | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#webpage", "url": "https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html", "name": "Coroutine context and dispatchers | Kotlin", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://kotlinlang.org/docs#website", "url": "https://kotlinlang.org/docs", "name": "Kotlin Help" }</script><!-- End Schema.org --></head>    <body data-id="coroutine-context-and-dispatchers" data-main-title="Coroutine context and dispatchers" data-article-props='{"seeAlsoStyle":"links"}' data-template="article" data-breadcrumbs="Official libraries///Coroutines (kotlinx.coroutines)" data-edit-url="https://github.com/Kotlin/kotlinx.coroutines/edit/master/docs/topics/coroutine-context-and-dispatchers.md">  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">  </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="coroutine-context-and-dispatchers" id="coroutine-context-and-dispatchers.md">Coroutine context and dispatchers</h1><p id="26b07a7d">Coroutines always execute in some context represented by a value of the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/" id="9b226353" data-external="true" rel="noopener noreferrer">CoroutineContext</a> type, defined in the Kotlin standard library.</p><p id="c406b2af">The coroutine context is a set of various elements. The main elements are the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="c0f00a9c" data-external="true" rel="noopener noreferrer">Job</a> of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</p><section class="chapter"><h2 id="dispatchers-and-threads" data-toc="coroutine-context-and-dispatchers#dispatchers-and-threads">Dispatchers and threads</h2><p id="641fc81b">The coroutine context includes a <em id="2f8af5d8" class="">coroutine dispatcher</em> (see <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" id="f31da582" data-external="true" rel="noopener noreferrer">CoroutineDispatcher</a>) that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.</p><p id="e72842f4">All coroutine builders like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" id="8bdb1c54" data-external="true" rel="noopener noreferrer">launch</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" id="3e074fe" data-external="true" rel="noopener noreferrer">async</a> accept an optional <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/" id="2fc18541" data-external="true" rel="noopener noreferrer">CoroutineContext</a> parameter that can be used to explicitly specify the dispatcher for the new coroutine and other context elements.</p><p id="afbc38c6">Try the following example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch { // context of the parent, main runBlocking coroutine
        println("main runBlocking      : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println("Unconfined            : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher 
        println("Default               : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(newSingleThreadContext("MyOwnThread")) { // will get its own new thread
        println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")
    }
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="5c8acdbb"><p id="e36880b3">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-01.kt" id="efdcf95" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="7470972">It produces the following output (maybe in different order):</p><div class="code-block" data-lang="plaintext">Unconfined            : I'm working in thread main
Default               : I'm working in thread DefaultDispatcher-worker-1
newSingleThreadContext: I'm working in thread MyOwnThread
main runBlocking      : I'm working in thread main
</div><p id="5fc06349">When <code class="code ">launch { ... }</code> is used without parameters, it inherits the context (and thus dispatcher) from the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="5430cc8" data-external="true" rel="noopener noreferrer">CoroutineScope</a> it is being launched from. In this case, it inherits the context of the main <code class="code ">runBlocking</code> coroutine which runs in the <code class="code ">main</code> thread.</p><p id="86a6fec3"><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" id="16d1ee09" data-external="true" rel="noopener noreferrer">Dispatchers.Unconfined</a> is a special dispatcher that also appears to run in the <code class="code ">main</code> thread, but it is, in fact, a different mechanism that is explained later.</p><p id="37cbfdac">The default dispatcher is used when no other dispatcher is explicitly specified in the scope. It is represented by <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" id="b7cbef2f" data-external="true" rel="noopener noreferrer">Dispatchers.Default</a> and uses a shared background pool of threads.</p><p id="50968255"><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html" id="600af09f" data-external="true" rel="noopener noreferrer">newSingleThreadContext</a> creates a thread for the coroutine to run. A dedicated thread is a very expensive resource. In a real application it must be either released, when no longer needed, using the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/close.html" id="985631d" data-external="true" rel="noopener noreferrer">close</a> function, or stored in a top-level variable and reused throughout the application.</p></section><section class="chapter"><h2 id="unconfined-vs-confined-dispatcher" data-toc="coroutine-context-and-dispatchers#unconfined-vs-confined-dispatcher">Unconfined vs confined dispatcher</h2><p id="9241ecb4">The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" id="229250e5" data-external="true" rel="noopener noreferrer">Dispatchers.Unconfined</a> coroutine dispatcher starts a coroutine in the caller thread, but only until the first suspension point. After suspension it resumes the coroutine in the thread that is fully determined by the suspending function that was invoked. The unconfined dispatcher is appropriate for coroutines which neither consume CPU time nor update any shared data (like UI) confined to a specific thread.</p><p id="f6114e9a">On the other side, the dispatcher is inherited from the outer <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="c595532c" data-external="true" rel="noopener noreferrer">CoroutineScope</a> by default. The default dispatcher for the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" id="97ba73d2" data-external="true" rel="noopener noreferrer">runBlocking</a> coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with predictable FIFO scheduling.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println("Unconfined      : I'm working in thread ${Thread.currentThread().name}")
        delay(500)
        println("Unconfined      : After delay in thread ${Thread.currentThread().name}")
    }
    launch { // context of the parent, main runBlocking coroutine
        println("main runBlocking: I'm working in thread ${Thread.currentThread().name}")
        delay(1000)
        println("main runBlocking: After delay in thread ${Thread.currentThread().name}")
    }
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="28c66a65"><p id="8984fa69">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-02.kt" id="5812fe2f" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="cf275754">Produces the output:</p><div class="code-block" data-lang="plaintext">Unconfined      : I'm working in thread main
main runBlocking: I'm working in thread main
Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor
main runBlocking: After delay in thread main
</div><p id="a822f998">So, the coroutine with the context inherited from <code class="code ">runBlocking {...}</code> continues to execute in the <code class="code ">main</code> thread, while the unconfined one resumes in the default executor thread that the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" id="56361562" data-external="true" rel="noopener noreferrer">delay</a> function is using.</p><aside data-type="note" class="prompt" data-title="" id="5b891d22"><p id="d8478229">The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</p></aside></section><section class="chapter"><h2 id="debugging-coroutines-and-threads" data-toc="coroutine-context-and-dispatchers#debugging-coroutines-and-threads">Debugging coroutines and threads</h2><p id="965147ca">Coroutines can suspend on one thread and resume on another thread. Even with a single-threaded dispatcher it might be hard to figure out what the coroutine was doing, where, and when if you don't have special tooling.</p><section class="chapter"><h3 id="debugging-with-idea" data-toc="coroutine-context-and-dispatchers#debugging-with-idea">Debugging with IDEA</h3><p id="7144923f">The Coroutine Debugger of the Kotlin plugin simplifies debugging coroutines in IntelliJ IDEA.</p><aside data-type="note" class="prompt" data-title="" id="fc1ae1b6"><p id="510d78d3">Debugging works for versions 1.3.8 or later of <code class="code ">kotlinx-coroutines-core</code>.</p></aside><p id="647d9619">The <b id="def21a44" class="">Debug</b> tool window contains the <b id="509cc5dc" class="">Coroutines</b> tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</p><figure class=" " id="74b2f185"><img alt="Debugging coroutines" title="Debugging coroutines" src="images/coroutine-idea-debugging-1.png" class=" " width="700" height="183"></figure><p id="62df2943">With the coroutine debugger, you can:</p><ul class="list _ul" id="5ae97abd"><li class="list__item" id="d01ae040"><p>Check the state of each coroutine.</p></li><li class="list__item" id="cd0fff3c"><p>See the values of local and captured variables for both running and suspended coroutines.</p></li><li class="list__item" id="4e6ef392"><p>See a full coroutine creation stack, as well as a call stack inside the coroutine. The stack includes all frames with variable values, even those that would be lost during standard debugging.</p></li><li class="list__item" id="a5da4edc"><p>Get a full report that contains the state of each coroutine and its stack. To obtain it, right-click inside the <b id="6c6f783f" class="">Coroutines</b> tab, and then click <b id="6ca79ed2" class="">Get Coroutines Dump</b>.</p></li></ul><p id="1de87a16">To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</p><p id="a2c63fe3">Learn more about coroutines debugging in the <a href="https://kotlinlang.org/docs/tutorials/coroutines/debug-coroutines-with-idea.html" id="6f991a5" data-external="true" rel="noopener noreferrer">tutorial</a>.</p></section><section class="chapter"><h3 id="debugging-using-logging" data-toc="coroutine-context-and-dispatchers#debugging-using-logging">Debugging using logging</h3><p id="b47fff60">Another approach to debugging applications with threads without Coroutine Debugger is to print the thread name in the log file on each log statement. This feature is universally supported by logging frameworks. When using coroutines, the thread name alone does not give much of a context, so <code class="code ">kotlinx.coroutines</code> includes debugging facilities to make it easier.</p><p id="80b3a35c">Run the following code with <code class="code ">-Dkotlinx.coroutines.debug</code> JVM option:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val a = async {
        log("I'm computing a piece of the answer")
        6
    }
    val b = async {
        log("I'm computing another piece of the answer")
        7
    }
    log("The answer is ${a.await() * b.await()}")
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="9340638"><p id="8d11b295">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-03.kt" id="33ee8eec" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="794dfb3f">There are three coroutines. The main coroutine (#1) inside <code class="code ">runBlocking</code> and two coroutines computing the deferred values <code class="code ">a</code> (#2) and <code class="code ">b</code> (#3). They are all executing in the context of <code class="code ">runBlocking</code> and are confined to the main thread. The output of this code is:</p><div class="code-block" data-lang="plaintext">[main @coroutine#2] I'm computing a piece of the answer
[main @coroutine#3] I'm computing another piece of the answer
[main @coroutine#1] The answer is 42
</div><p id="9327d1d7">The <code class="code ">log</code> function prints the name of the thread in square brackets, and you can see that it is the <code class="code ">main</code> thread with the identifier of the currently executing coroutine appended to it. This identifier is consecutively assigned to all created coroutines when the debugging mode is on.</p><aside data-type="note" class="prompt" data-title="" id="9fbafde3"><p id="c38af8a">Debugging mode is also turned on when JVM is run with <code class="code ">-ea</code> option. You can read more about debugging facilities in the documentation of the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-d-e-b-u-g_-p-r-o-p-e-r-t-y_-n-a-m-e.html" id="455aaab9" data-external="true" rel="noopener noreferrer">DEBUG_PROPERTY_NAME</a> property.</p></aside></section></section><section class="chapter"><h2 id="jumping-between-threads" data-toc="coroutine-context-and-dispatchers#jumping-between-threads">Jumping between threads</h2><p id="9f7daaa2">Run the following code with the <code class="code ">-Dkotlinx.coroutines.debug</code> JVM option (see <a href="#debugging-coroutines-and-threads" id="270beb55">debug</a>):</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() {
//sampleStart
    newSingleThreadContext("Ctx1").use { ctx1 -&gt;
        newSingleThreadContext("Ctx2").use { ctx2 -&gt;
            runBlocking(ctx1) {
                log("Started in ctx1")
                withContext(ctx2) {
                    log("Working in ctx2")
                }
                log("Back to ctx1")
            }
        }
    }
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="2888fafa"><p id="c9f19a62">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-04.kt" id="2c2cea7a" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="fda5ac34">It demonstrates several new techniques. One is using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" id="52437d4a" data-external="true" rel="noopener noreferrer">runBlocking</a> with an explicitly specified context, and the other one is using the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" id="97b8e6ab" data-external="true" rel="noopener noreferrer">withContext</a> function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</p><div class="code-block" data-lang="plaintext">[Ctx1 @coroutine#1] Started in ctx1
[Ctx2 @coroutine#1] Working in ctx2
[Ctx1 @coroutine#1] Back to ctx1
</div><p id="ad5dc73f">Note that this example also uses the <code class="code ">use</code> function from the Kotlin standard library to release threads created with <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html" id="6e99884e" data-external="true" rel="noopener noreferrer">newSingleThreadContext</a> when they are no longer needed.</p></section><section class="chapter"><h2 id="job-in-the-context" data-toc="coroutine-context-and-dispatchers#job-in-the-context">Job in the context</h2><p id="268100da">The coroutine's <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="61ada068" data-external="true" rel="noopener noreferrer">Job</a> is part of its context, and can be retrieved from it using the <code class="code ">coroutineContext[Job]</code> expression:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    println("My job is ${coroutineContext[Job]}")
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="ce65f95f"><p id="1e4b7745">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-05.kt" id="a3f8ebaa" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="11edcac">In the <a href="#debugging-coroutines-and-threads" id="90b9d872">debug mode</a>, it outputs something like this:</p><p> <code class="code ">My job is "coroutine#1":BlockingCoroutine{Active}@6d311334</code> </p><p id="98bb717c">Note that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html" id="10629973" data-external="true" rel="noopener noreferrer">isActive</a> in <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="d86c0d32" data-external="true" rel="noopener noreferrer">CoroutineScope</a> is just a convenient shortcut for <code class="code ">coroutineContext[Job]?.isActive == true</code>.</p></section><section class="chapter"><h2 id="children-of-a-coroutine" data-toc="coroutine-context-and-dispatchers#children-of-a-coroutine">Children of a coroutine</h2><p id="c89ff95b">When a coroutine is launched in the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="ce930339" data-external="true" rel="noopener noreferrer">CoroutineScope</a> of another coroutine, it inherits its context via <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html" id="18277fde" data-external="true" rel="noopener noreferrer">CoroutineScope.coroutineContext</a> and the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="a7ffda70" data-external="true" rel="noopener noreferrer">Job</a> of the new coroutine becomes a <em id="6f25dd38" class="">child</em> of the parent coroutine's job. When the parent coroutine is cancelled, all its children are recursively cancelled, too.</p><p id="c3a1e2e3">However, this parent-child relation can be explicitly overriden in one of two ways:</p><ol class="list _decimal" id="d7e609af"><li class="list__item" id="3345fc89"><p>When a different scope is explicitly specified when launching a coroutine (for example, <code class="code ">GlobalScope.launch</code>), then it does not inherit a <code class="code ">Job</code> from the parent scope.</p></li><li class="list__item" id="719c27cd"><p>When a different <code class="code ">Job</code> object is passed as the context for the new coroutine (as shown in the example below), then it overrides the <code class="code ">Job</code> of the parent scope.</p></li></ol><p id="694e0303">In both cases, the launched coroutine is not tied to the scope it was launched from and operates independently.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        // it spawns two other jobs
        launch(Job()) { 
            println("job1: I run in my own Job and execute independently!")
            delay(1000)
            println("job1: I am not affected by cancellation of the request")
        }
        // and the other inherits the parent context
        launch {
            delay(100)
            println("job2: I am a child of the request coroutine")
            delay(1000)
            println("job2: I will not execute this line if my parent request is cancelled")
        }
    }
    delay(500)
    request.cancel() // cancel processing of the request
    delay(1000) // delay a second to see what happens
    println("main: Who has survived request cancellation?")
//sampleEnd
}
</div><aside data-type="note" class="prompt" data-title="" id="35f6b526"><p id="26dcd090">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-06.kt" id="fac8d5f8" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="40fd76f2">The output of this code is:</p><div class="code-block" data-lang="plaintext">job1: I run in my own Job and execute independently!
job2: I am a child of the request coroutine
job1: I am not affected by cancellation of the request
main: Who has survived request cancellation?
</div></section><section class="chapter"><h2 id="parental-responsibilities" data-toc="coroutine-context-and-dispatchers#parental-responsibilities">Parental responsibilities</h2><p id="5baec55b">A parent coroutine always waits for completion of all its children. A parent does not have to explicitly track all the children it launches, and it does not have to use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html" id="5ec5d036" data-external="true" rel="noopener noreferrer">Job.join</a> to wait for them at the end:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        repeat(3) { i -&gt; // launch a few children jobs
            launch  {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms
                println("Coroutine $i is done")
            }
        }
        println("request: I'm done and I don't explicitly join my children that are still active")
    }
    request.join() // wait for completion of the request, including all its children
    println("Now processing of the request is complete")
//sampleEnd
}
</div><aside data-type="note" class="prompt" data-title="" id="4f2f25e9"><p id="ee709628">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-07.kt" id="e0547b77" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="ccf90bbf">The result is going to be:</p><div class="code-block" data-lang="plaintext">request: I'm done and I don't explicitly join my children that are still active
Coroutine 0 is done
Coroutine 1 is done
Coroutine 2 is done
Now processing of the request is complete
</div></section><section class="chapter"><h2 id="naming-coroutines-for-debugging" data-toc="coroutine-context-and-dispatchers#naming-coroutines-for-debugging">Naming coroutines for debugging</h2><p id="134a1cb3">Automatically assigned ids are good when coroutines log often and you just need to correlate log records coming from the same coroutine. However, when a coroutine is tied to the processing of a specific request or doing some specific background task, it is better to name it explicitly for debugging purposes. The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html" id="5d42747d" data-external="true" rel="noopener noreferrer">CoroutineName</a> context element serves the same purpose as the thread name. It is included in the thread name that is executing this coroutine when the <a href="#debugging-coroutines-and-threads" id="d113a0f">debugging mode</a> is turned on.</p><p id="3f912823">The following example demonstrates this concept:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking(CoroutineName("main")) {
//sampleStart
    log("Started main coroutine")
    // run two background value computations
    val v1 = async(CoroutineName("v1coroutine")) {
        delay(500)
        log("Computing v1")
        252
    }
    val v2 = async(CoroutineName("v2coroutine")) {
        delay(1000)
        log("Computing v2")
        6
    }
    log("The answer for v1 / v2 = ${v1.await() / v2.await()}")
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="d34a57e2"><p id="50344552">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-08.kt" id="bb7eb423" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="b26cff4b">The output it produces with <code class="code ">-Dkotlinx.coroutines.debug</code> JVM option is similar to:</p><div class="code-block" data-lang="plaintext">[main @main#1] Started main coroutine
[main @v1coroutine#2] Computing v1
[main @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
</div></section><section class="chapter"><h2 id="combining-context-elements" data-toc="coroutine-context-and-dispatchers#combining-context-elements">Combining context elements</h2><p id="eb56a3dc">Sometimes we need to define multiple elements for a coroutine context. We can use the <code class="code ">+</code> operator for that. For example, we can launch a coroutine with an explicitly specified dispatcher and an explicitly specified name at the same time:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Default + CoroutineName("test")) {
        println("I'm working in thread ${Thread.currentThread().name}")
    }
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="96887d14"><p id="6bfd6ea9">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-09.kt" id="e825255d" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="c3b187af">The output of this code with the <code class="code ">-Dkotlinx.coroutines.debug</code> JVM option is:</p><div class="code-block" data-lang="plaintext">I'm working in thread DefaultDispatcher-worker-1 @test#2
</div></section><section class="chapter"><h2 id="coroutine-scope" data-toc="coroutine-context-and-dispatchers#coroutine-scope">Coroutine scope</h2><p id="a550ce46">Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but <code class="code ">kotlinx.coroutines</code> provides an abstraction encapsulating that: <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="2ecd525c" data-external="true" rel="noopener noreferrer">CoroutineScope</a>. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</p><p id="9baeadb0">We manage the lifecycles of our coroutines by creating an instance of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="f1493fd" data-external="true" rel="noopener noreferrer">CoroutineScope</a> tied to the lifecycle of our activity. A <code class="code ">CoroutineScope</code> instance can be created by the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html" id="5f702f26" data-external="true" rel="noopener noreferrer">CoroutineScope()</a> or <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html" id="418d40f9" data-external="true" rel="noopener noreferrer">MainScope()</a> factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" id="6c006a7c" data-external="true" rel="noopener noreferrer">Dispatchers.Main</a> as the default dispatcher:</p><div class="code-block" data-lang="kotlin">class Activity {
    private val mainScope = MainScope()
    
    fun destroy() {
        mainScope.cancel()
    }
    // to be continued ...
</div><p id="426a1c19">Now, we can launch coroutines in the scope of this <code class="code ">Activity</code> using the defined <code class="code ">scope</code>. For the demo, we launch ten coroutines that delay for a different time:</p><div class="code-block" data-lang="kotlin">    // class Activity continues
    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println("Coroutine $i is done")
            }
        }
    }
} // class Activity ends
</div><p id="3a616bec">In our main function we create the activity, call our test <code class="code ">doSomething</code> function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from <code class="code ">doSomething</code>. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

class Activity {
    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes
    
    fun destroy() {
        mainScope.cancel()
    }

    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println("Coroutine $i is done")
            }
        }
    }
} // class Activity ends

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val activity = Activity()
    activity.doSomething() // run test function
    println("Launched coroutines")
    delay(500L) // delay for half a second
    println("Destroying activity!")
    activity.destroy() // cancels all coroutines
    delay(1000) // visually confirm that they don't work
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="a8e53cc9"><p id="df16d39d">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-10.kt" id="8a428577" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="281de12">The output of this example is:</p><div class="code-block" data-lang="plaintext">Launched coroutines
Coroutine 0 is done
Coroutine 1 is done
Destroying activity!
</div><p id="4e22f71c">As you can see, only the first two coroutines print a message and the others are cancelled by a single invocation of <code class="code ">job.cancel()</code> in <code class="code ">Activity.destroy()</code>.</p><aside data-type="note" class="prompt" data-title="" id="804731f9"><p id="60a670ca">Note, that Android has first-party support for coroutine scope in all entities with the lifecycle. See <a href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope" id="63aeb6f9" data-external="true" rel="noopener noreferrer">the corresponding documentation</a>.</p></aside><section class="chapter"><h3 id="thread-local-data" data-toc="coroutine-context-and-dispatchers#thread-local-data">Thread-local data</h3><p id="6806619a">Sometimes it is convenient to have an ability to pass some thread-local data to or between coroutines. However, since they are not bound to any particular thread, this will likely lead to boilerplate if done manually.</p><p id="74c6a07b">For <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" id="6d12f233" data-external="true" rel="noopener noreferrer"><code class="code ">ThreadLocal</code></a>, the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html" id="8574ab7a" data-external="true" rel="noopener noreferrer">asContextElement</a> extension function is here for the rescue. It creates an additional context element which keeps the value of the given <code class="code ">ThreadLocal</code> and restores it every time the coroutine switches its context.</p><p id="fb273f1">It is easy to demonstrate it in action:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">import kotlinx.coroutines.*

val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    threadLocal.set("main")
    println("Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = "launch")) {
        println("Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
        yield()
        println("After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
    }
    job.join()
    println("Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
//sampleEnd    
}
</div><aside data-type="note" class="prompt" data-title="" id="66397abe"><p id="101a6aea">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-context-11.kt" id="a7a66d17" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="a9fa058f">In this example we launch a new coroutine in a background thread pool using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" id="c51ef15e" data-external="true" rel="noopener noreferrer">Dispatchers.Default</a>, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using <code class="code ">threadLocal.asContextElement(value = "launch")</code>, no matter which thread the coroutine is executed on. Thus, the output (with <a href="#debugging-coroutines-and-threads" id="406ffb3a">debug</a>) is:</p><div class="code-block" data-lang="plaintext">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'
After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'
Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
</div><p id="69c37e6c">It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-present.html" id="f5e06a36" data-external="true" rel="noopener noreferrer">ensurePresent</a> method and fail-fast on improper usages.</p><p id="d27ee233"><code class="code ">ThreadLocal</code> has first-class support and can be used with any primitive <code class="code ">kotlinx.coroutines</code> provides. It has one key limitation, though: when a thread-local is mutated, a new value is not propagated to the coroutine caller (because a context element cannot track all <code class="code ">ThreadLocal</code> object accesses), and the updated value is lost on the next suspension. Use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" id="af4a4423" data-external="true" rel="noopener noreferrer">withContext</a> to update the value of the thread-local in a coroutine, see <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html" id="e1c974e5" data-external="true" rel="noopener noreferrer">asContextElement</a> for more details.</p><p id="f4738837">Alternatively, a value can be stored in a mutable box like <code class="code ">class Counter(var i: Int)</code>, which is, in turn, stored in a thread-local variable. However, in this case you are fully responsible to synchronize potentially concurrent modifications to the variable in this mutable box.</p><p id="57ee55b7">For advanced usage, for example for integration with logging MDC, transactional contexts or any other libraries which internally use thread-locals for passing data, see the documentation of the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html" id="ccb106f" data-external="true" rel="noopener noreferrer">ThreadContextElement</a> interface that should be implemented.</p></section></section><div class="last-modified"> Last modified: 04 April 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="composing-suspending-functions.html">Composing suspending functions</a>   <a class="navigation-links__next" href="flow.html">Asynchronous Flow</a>  </div></article>  </div></section></main></div>  <script src="static/v3/app.js"></script>  </body></html>